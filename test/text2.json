"#include \"avm.h\"\r\n\r\n#include <memory>\r\n#include <iostream>\r\n#include <string>\r\n#include <iostream>\r\n#include <fstream>\r\n#include \"str_switch/str_switch.h\"\r\n\r\nusing namespace std;\r\nusing namespace Platform::Data::Doublets::Memory::United::Generic;\r\n\r\n/*\r\n\tПлан:\r\n\r\nСделать версию которая десериализует json в АМО а потом сериализует\r\n на ней отработать преобразование и его корректность\r\n\r\n1. сериализация/десериализация null................V\r\n2. сериализация/десериализация bool................V\r\n3. сериализация/десериализация array...............V\r\n4. сериализация/десериализация number..............\r\n5. сериализация/десериализация string..............\r\n6. сериализация/десериализация object..............\r\n\r\nЕсть вариант для простых типов данных смоделировать память с линейной дресацией через бинарное дерево.\r\nМожно использовать 16-тиричную систему адресов.\r\nЛибо использовать 2х уровневую система адресации:\r\n1. последовательность бит (true/false) для описания байт\r\n2. последовательность байт (букв) для описания чисел и строк\r\n\r\nДля создания root json документа надо уметь создавать:\r\n1. bit: false/true\r\n2. array\r\n3. number is array of bits\r\n4. string is array of numbers\r\n5. object is string tree\r\n\r\n\r\n\r\n\tПроблемы:\r\n\r\n1. хранение и освобождение ent/rel\r\n2. непонятно как представлять примитивные типы, такие как bool, числа и строки.\r\n\tНа первое время есть вариант создать для данных типов встроенные сущности.\r\n\tВторой вариант использовать одно и тоже отношение для обозначения последовательности,\r\n\tно в зависимости от сущности первичного субъекта определять примитивный тип\r\n\r\n\tРазмышления:\r\n\r\nЕсли 1 бит есть значение bool, а число как битовая последовательность\r\nиспользуются для адресации в бинарном дереве,\r\nа бинарное дерево образовано троичными сущностями,\r\nто true/false должны выбирать между правой/левой веткой, т.е. obj/sub.\r\nЭто ещё одно подтверждение, что obj/sub однозначно соответствуют true/false,\r\nа так же понятию правый/левый.\r\n\r\narray это компактная сериализация дерева map, которая может использоваться для адресации в бинарном дереве.\r\n\r\n*/\r\n\r\nvoid get_json(json &ent, const string &PathName)\r\n{\r\n\tstd::ifstream in(PathName.c_str());\r\n\tif (!in.good())\r\n\t\tthrow runtime_error(__func__ + \": Can't load json from the \"s + PathName + \" file!\");\r\n\tin >> ent;\r\n}\r\n\r\nvoid add_json(const json &ent, const string &PathName)\r\n{\r\n\tstd::ofstream out(PathName.c_str());\r\n\tif (!out.good())\r\n\t\tthrow runtime_error(__func__ + \": Can't open \"s + PathName + \" file!\"s);\r\n\tout << ent;\r\n}\r\n\r\nrel_t *import_json(const json &j)\r\n{\r\n\tswitch (j.type())\r\n\t{\r\n\tcase json::value_t::null: //\tnull - означает отсутствие сущности\r\n\t\treturn rel_t::E;\r\n\r\n\tcase json::value_t::boolean:\r\n\t\tif (j.get<bool>())\r\n\t\t\treturn rel_t::True;\r\n\t\telse\r\n\t\t\treturn rel_t::False;\r\n\r\n\tcase json::value_t::array: //\tлямбда вектор, который управляет последовательным изменением отношения сущности\r\n\t{\r\n\t\tauto array = rel_t::E;\r\n\r\n\t\tfor (auto &it : j)\r\n\t\t\tarray = rel_t::rel(rel_t::rel(array, import_json(it)), rel_t::R);\r\n\t\treturn array;\r\n\t}\r\n\r\n\tcase json::value_t::number_unsigned:\r\n\t{\r\n\t\tjson::number_unsigned_t val = j.get<json::number_unsigned_t>();\r\n\t\tauto array = rel_t::E;\r\n\t\tfor (json::number_unsigned_t i = 1; i; i <<= 1)\r\n\t\t\tarray = rel_t::rel(rel_t::rel(array, (val & i) ? rel_t::True : rel_t::False), rel_t::R);\r\n\t\treturn array = rel_t::rel(array, rel_t::Unsigned);\r\n\t}\r\n\r\n\tcase json::value_t::number_integer:\r\n\t{\r\n\t\tjson::number_integer_t ival = j.get<json::number_integer_t>();\r\n\t\tjson::number_unsigned_t val = *reinterpret_cast<json::number_unsigned_t *>(&ival);\r\n\t\tauto array = rel_t::E;\r\n\t\tfor (json::number_unsigned_t i = 1; i; i <<= 1)\r\n\t\t\tarray = rel_t::rel(rel_t::rel(array, (val & i) ? rel_t::True : rel_t::False), rel_t::R);\r\n\t\treturn array = rel_t::rel(array, rel_t::Integer);\r\n\t}\r\n\r\n\tcase json::value_t::number_float:\r\n\t{\r\n\t\tjson::number_float_t fval = j.get<json::number_float_t>();\r\n\t\tjson::number_unsigned_t val = *reinterpret_cast<json::number_unsigned_t *>(&fval);\r\n\t\tauto array = rel_t::E;\r\n\t\tfor (json::number_unsigned_t i = 1; i; i <<= 1)\r\n\t\t\tarray = rel_t::rel(rel_t::rel(array, (val & i) ? rel_t::True : rel_t::False), rel_t::R);\r\n\t\treturn array = rel_t::rel(array, rel_t::Float);\r\n\t}\r\n\r\n\tcase json::value_t::string:\r\n\t{\r\n\t\tauto str = j.get<string>();\r\n\t\tauto array = rel_t::E;\r\n\r\n\t\tfor (auto &it : str)\r\n\t\t{\r\n\t\t\tuint8_t val = *reinterpret_cast<uint8_t *>(&it);\r\n\t\t\tauto sing = rel_t::E;\r\n\t\t\tfor (uint8_t i = 1; i; i <<= 1)\r\n\t\t\t\tsing = rel_t::rel(rel_t::rel(sing, (val & i) ? rel_t::True : rel_t::False), rel_t::R);\r\n\t\t\tarray = rel_t::rel(rel_t::rel(array, sing), rel_t::R);\r\n\t\t}\r\n\t\treturn array = rel_t::rel(array, rel_t::String);\r\n\t}\r\n\r\n\tcase json::value_t::object:\r\n\t{\r\n\t\t/*auto end = j.end();\r\n\r\n\t\tif (auto ref = j.find(\"$ref\"); ref != end)\r\n\t\t{ //\tэто ссылка на json значение\r\n\t\t\tif (ref->is_string())\r\n\t\t\t{\r\n\t\t\t\t// try { exec_ent($, string_ref_to<rval>($, ref->get_ref<string const&>())); }\r\n\t\t\t\t// catch (json& j) { throw json({ {ref->get_ref<string const&>(), j} }); }\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tthrow json({{\"$ref\", *ref}});\r\n\t\t}\r\n\t\telse if (auto rel = j.find(\"$rel\"); rel != end)\r\n\t\t{ //\tэто сущность, которую надо исполнить в новом контексте?\r\n\t\t\tauto obj = j.find(\"$obj\");\r\n\t\t\tauto sub = j.find(\"$sub\");\r\n\t\t}\r\n\t\telse\r\n\t\t{ //\tконтроллер это лямбда структура, которая управляет параллельным проецированием сущностей\r\n\t\t\tauto it = j.begin();\r\n\r\n\t\t\t// for (auto &it : vct)\r\n\t\t\t// if (!it.exc.is_null())\r\n\t\t\t//  throw json({ {it.key, it.exc} });\r\n\t\t}*/\r\n\t\treturn rel_t::E;\r\n\t}\r\n\r\n\tdefault:\r\n\t\treturn rel_t::E;\r\n\t}\r\n}\r\n\r\nvoid export_json(const rel_t *ent, json &j)\r\n{\r\n\tif (ent == rel_t::E) //\tR[E]\r\n\t\tj = json();\t\t //\tnull\r\n\telse if (ent == rel_t::True)\r\n\t\tj = json(true);\r\n\telse if (ent == rel_t::False)\r\n\t\tj = json(false);\r\n\telse if (ent->sub == rel_t::E && ent->obj == rel_t::E) //\tE[E]\r\n\t{\r\n\t\tj = json::array();\r\n\t\tj.push_back(json());\r\n\t}\r\n\telse if (ent->obj == rel_t::R) //\tsub[R]\r\n\t{\r\n\t\texport_json(ent->sub->sub, j);\r\n\t\tif (j.is_null())\r\n\t\t\tj = json::array();\r\n\t\tjson last;\r\n\t\texport_json(ent->sub->obj, last);\r\n\t\tj.push_back(last);\r\n\t}\r\n\telse if (ent->obj == rel_t::String) //\tsub[Char]\r\n\t{\r\n\t\texport_json(ent->sub, j);\r\n\t\tif (j.is_array())\r\n\t\t{\r\n\t\t\tjson::string_t str{};\r\n\t\t\tfor (auto &sing : j)\r\n\t\t\t\tif (sing.is_array())\r\n\t\t\t\t{\r\n\t\t\t\t\tuint8_t val{}, i{1};\r\n\t\t\t\t\tfor (auto &it : sing)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (it.is_boolean())\r\n\t\t\t\t\t\t\tif (it.get<bool>())\r\n\t\t\t\t\t\t\t\tval |= i;\r\n\t\t\t\t\t\ti <<= 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstr += *reinterpret_cast<char *>(&val);\r\n\t\t\t\t}\r\n\t\t\tj = json(str);\r\n\t\t}\r\n\t}\r\n\telse if (ent->obj == rel_t::Unsigned) //\tsub[Unsigned]\r\n\t{\r\n\t\texport_json(ent->sub, j);\r\n\t\tif (j.is_array())\r\n\t\t{\r\n\t\t\tjson::number_unsigned_t val{}, i{1};\r\n\t\t\tfor (auto &it : j)\r\n\t\t\t{\r\n\t\t\t\tif (it.is_boolean())\r\n\t\t\t\t\tif (it.get<bool>())\r\n\t\t\t\t\t\tval |= i;\r\n\t\t\t\ti <<= 1;\r\n\t\t\t}\r\n\t\t\tj = json(val);\r\n\t\t}\r\n\t}\r\n\telse if (ent->obj == rel_t::Integer) //\tsub[Integer]\r\n\t{\r\n\t\texport_json(ent->sub, j);\r\n\t\tif (j.is_array())\r\n\t\t{\r\n\t\t\tjson::number_unsigned_t val{}, i{1};\r\n\t\t\tfor (auto &it : j)\r\n\t\t\t{\r\n\t\t\t\tif (it.is_boolean())\r\n\t\t\t\t\tif (it.get<bool>())\r\n\t\t\t\t\t\tval |= i;\r\n\t\t\t\ti <<= 1;\r\n\t\t\t}\r\n\t\t\tj = json(*reinterpret_cast<json::number_integer_t *>(&val));\r\n\t\t}\r\n\t}\r\n\telse if (ent->obj == rel_t::Float) //\tsub[Float]\r\n\t{\r\n\t\texport_json(ent->sub, j);\r\n\t\tif (j.is_array())\r\n\t\t{\r\n\t\t\tjson::number_unsigned_t val{}, i{1};\r\n\t\t\tfor (auto &it : j)\r\n\t\t\t{\r\n\t\t\t\tif (it.is_boolean())\r\n\t\t\t\t\tif (it.get<bool>())\r\n\t\t\t\t\t\tval |= i;\r\n\t\t\t\ti <<= 1;\r\n\t\t\t}\r\n\t\t\tj = json(*reinterpret_cast<json::number_float_t *>(&val));\r\n\t\t}\r\n\t}\r\n\telse\r\n\t\tj = json(\"is string\");\r\n}\r\n\r\nsize_t link_name(vector<json *> &sub, const string &str, size_t start_pos, size_t end_pos)\r\n{\r\n\tif (end_pos > start_pos)\r\n\t{\r\n\t\tauto name = str.substr(start_pos, end_pos - start_pos);\r\n\t\tauto res = sub.back()->find(name);\r\n\r\n\t\tif (res == sub.back()->end())\r\n\t\t\tsub.back() = &((*sub.back())[name] = json::object());\r\n\t\telse\r\n\t\t\tsub.back() = &res.value();\r\n\t}\r\n\treturn end_pos + 1;\r\n}\r\n\r\njson &parse_string(json &rel, const string &str) noexcept\r\n{\r\n\tsize_t pos = 0, last_pos = 0;\r\n\tvector<json *> sub;\r\n\tvector<size_t> start_pos; //\tначальная позиция после [\r\n\r\n\tsub.push_back(&rel); //\tпо умолчанию субъектом является корневое отношение\r\n\tstart_pos.push_back(pos);\r\n\r\n\twhile (true) //\tберём следующую букву имени\r\n\t{\r\n\t\tswitch (str[pos])\r\n\t\t{\r\n\t\tcase ',': //\tследующая ассоциация\r\n\t\t\tsub.pop_back();\r\n\t\t\tlast_pos = link_name(sub, str, start_pos.back(), pos);\r\n\t\t\tstart_pos.pop_back();\r\n\t\tcase '[': //\tвложенная ассоциация\r\n\t\t\tstart_pos.push_back(link_name(sub, str, last_pos, pos));\r\n\t\t\tsub.push_back(&rel);\r\n\t\t\tlast_pos = start_pos.back();\r\n\t\t\tbreak;\r\n\r\n\t\tcase '.': //\tсущность\r\n\t\t\tstart_pos.push_back(link_name(sub, str, last_pos, pos));\r\n\t\t\tsub.push_back(&rel);\r\n\t\t\tlast_pos = start_pos.back();\r\n\t\tcase ']': //\tконец текущей вложенной ассоциации\r\n\t\t\tsub.pop_back();\r\n\t\t\tlast_pos = link_name(sub, str, start_pos.back(), pos);\r\n\t\t\tstart_pos.pop_back();\r\n\t\t\tbreak;\r\n\r\n\t\tcase '\\0':\r\n\t\t\treturn *sub.back();\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tpos++;\r\n\t}\r\n}\r\n\r\nvoid parse_json(const json &j, json &r)\r\n{\r\n\tswitch (j.type())\r\n\t{\r\n\tcase json::value_t::string:\r\n\t{\r\n\t\tparse_string(r, j.get_ref<string const &>());\r\n\t\treturn;\r\n\t}\r\n\r\n\tcase json::value_t::array:\r\n\t{\r\n\t\tauto it = j.cbegin();\r\n\t\tauto end = j.cend();\r\n\t\tfor (; it != end; ++it)\r\n\t\t\tparse_json(*it, r);\r\n\t\treturn;\r\n\t}\r\n\r\n\tdefault:\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n\t//\tlinks db test\r\n\t// UnitedMemoryLinks<uint64_t> links64(\"db.uint64_t.links\"s);\r\n\r\n\tjson res;\r\n\tchar *entry_point = NULL;\r\n\r\n\tswitch (argc)\r\n\t{\r\n\tcase 2:\r\n\t\tentry_point = argv[1];\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tcout << R\"(https://github.com/netkeep80/avm\r\n     Associative Virtual Machine [Version 0.0.1]\r\n             _____________\r\n            /             \\\r\n           /               \\\r\n          /                 +\r\n     ,--> E +---------------O----.\r\n    /     |                 A     \\\r\n   /      |  E =(O x S)x R  |      \\\r\n   |      |  O =(E x R)x S  |      |\r\n   |      |  S =(R x E)x O  |      |\r\n   \\      |  R =(S x O)x E  |      /\r\n    \\     V                 |     /\r\n     `----S---------------+ R <--`\r\n          +                 |\r\n           \\               /\r\n            \\_____________/\r\n\r\nE = OS = (ER * RE)\r\nO = ER = (OS * SO)\r\nS = RE = (SO * OS)\r\nR = SO = (RE * ER)\r\n\r\nLicensed under the MIT License <http://opensource.org/licenses/MIT>\r\nCopyright (c) 2022 Vertushkin Roman Pavlovich <https://vk.com/earthbirthbook>\r\n\r\nUsage:\r\n       avm.exe [entry_point]\r\n\t\t)\";\r\n\t\treturn 0; //\tok\r\n\t}\r\n\r\n\tjson root;\r\n\r\n\ttry\r\n\t{\r\n\t\tget_json(root, entry_point);\r\n\t\tres = json::object();\r\n\t\t// parse_json(root, res);\r\n\t\t//\tимпортируем в корневой контекст\r\n\t\tauto root_ent = import_json(root);\r\n\t\tcout << root.dump() << endl;\r\n\t\texport_json(root_ent, res);\r\n\t\tcout << res.dump() << endl;\r\n\t\tadd_json(res, \"res.json\"s);\r\n\t\tstd::cout << \"rel_t::created() = \" << rel_t::created() << std::endl;\r\n\t\treturn 0; //\tok\r\n\t}\r\n\tcatch (json &j)\r\n\t{\r\n\t\tcerr << j.dump(2);\r\n\t}\r\n\tcatch (json::exception &e)\r\n\t{\r\n\t\tcerr << __func__ << \"json::exception: \"s + e.what() + \", id: \"s + to_string(e.id);\r\n\t}\r\n\tcatch (std::exception &e)\r\n\t{\r\n\t\tcerr << __func__ << \"std::exception: \"s + e.what();\r\n\t}\r\n\tcatch (...)\r\n\t{\r\n\t\tcerr << __func__ << \"unknown exception\"s;\r\n\t}\r\n\r\n\tadd_json(root, \"rvm.dump.json\"s);\r\n\treturn 1; //\terror\r\n}\r\n"
